// This file is not generated by code

#include "test_cluster.h"

static void common_trace_snapshot_2_entries(CuTest *tc) {
    // init 3 servers, S0 becomes Leader
    info(1, "init 3 servers");                      rc_init_cluster(3, tc);
    info(2, "S0 becomes Candidate");                rc_election_timeout(0);
    info(2, "S0 sends RV 1 2 to S1 and S2");        assert_msg_seq_type(1, MSG_REQUESTVOTE); assert_msg_seq_type(2, MSG_REQUESTVOTE);
    info(3, "S1 receives RV 1");                    rc_deliver(1, MSG_REQUESTVOTE);
    info(3, "S1 sends RVR 3 (granted) to S0");      assert_msg_seq_type(3, MSG_REQUESTVOTE_RESPONSE);
    info(4, "S0 receives RVR 3 and become Leader"); rc_deliver(3, MSG_REQUESTVOTE_RESPONSE);
    info(4, "S0 sends AE 4 5 to S1 and S2");        assert_msg_seq_type(4, MSG_APPENDENTRIES); assert_msg_seq_type(5, MSG_APPENDENTRIES);
    info(5, "S1 S2 receives AE 4 5");               rc_deliver(4, MSG_APPENDENTRIES); rc_deliver(5, MSG_APPENDENTRIES);
    info(5, "S1 S2 sends AER 6 7");                 assert_msg_seq_type(6, MSG_APPENDENTRIES_RESPONSE); assert_msg_seq_type(7, MSG_APPENDENTRIES_RESPONSE);
    info(6, "S0 receives AER 6 7");                 rc_deliver(6, MSG_APPENDENTRIES_RESPONSE); rc_deliver(7, MSG_APPENDENTRIES_RESPONSE);
    // Client issues 2 entries, Leader S0 replicates those 2 entries to S1 and advances commit index to 2.
    // While S2's network is slow and S2 is lagged behind
    // Why 2 entries? Because making a snapshot needs at least 2 entries log count
    info(7, "Client sends CMD1 to S0");             rc_client_operation(0, CMD1);
    info(7, "S0 sends AE 8 9 to S1 and S2");        assert_msg_seq_type(8, MSG_APPENDENTRIES); assert_msg_seq_type(9, MSG_APPENDENTRIES);
    info(8, "S1 receives AE 8");                    rc_deliver(8, MSG_APPENDENTRIES);
    info(8, "S1 sends AER 10");                     assert_msg_seq_type(10, MSG_APPENDENTRIES_RESPONSE);
    info(9, "Client sends CMD1 to S0");             rc_client_operation(0, CMD1);
    info(9, "S0 will not send AE");                 assert_last_msg_type(MSG_APPENDENTRIES_RESPONSE);
    info(10, "S0 receives AER 10");                 rc_deliver(10, MSG_APPENDENTRIES_RESPONSE);
    info(10, "S0 aggressively sends AE 11");        assert_msg_seq_type(11, MSG_APPENDENTRIES);
    info(11, "S1 receives AE 11");                  rc_deliver(11, MSG_APPENDENTRIES);
    info(11, "S1 sends AER 12");                    assert_msg_seq_type(12, MSG_APPENDENTRIES_RESPONSE);
    info(12, "S0 receives AER 12");                 rc_deliver(12, MSG_APPENDENTRIES_RESPONSE);
    info(12, "S0 advance commit index to 2");       CuAssertIntEquals(tc, 2, raft_get_commit_idx(sv[0].server));
    // S2's network becomes good now
    info(13, "S2 receives RV 2");                   rc_deliver(2, MSG_REQUESTVOTE);
    info(13, "S2 sends RVR 13 (granted) to S0");    assert_msg_seq_type(13, MSG_REQUESTVOTE_RESPONSE);
    info(14, "S2 receives AE 9");                   rc_deliver(9, MSG_APPENDENTRIES);
    info(14, "S2 sends AER 14 to S0");              assert_msg_seq_type(14, MSG_APPENDENTRIES_RESPONSE);
    info(15, "S0 receives RVR 13");                 rc_deliver(13, MSG_REQUESTVOTE_RESPONSE);
    // Leader request times out and broadcasts heartbeats (sends two entries to S2)
    info(16, "S0 request times out");               rc_request_timeout(0);
    info(16, "S0 sends AE 15 16 to S1 and S2");     assert_msg_seq_type(15, MSG_APPENDENTRIES); assert_msg_seq_type(16, MSG_APPENDENTRIES);
    info(17, "S2 receives AE 16");                  rc_deliver(16, MSG_APPENDENTRIES);
    info(17, "S2 sends AER 17");                    assert_msg_seq_type(17, MSG_APPENDENTRIES_RESPONSE);
    info(18, "S2 has commit index 2");              CuAssertIntEquals(tc, 2, raft_get_commit_idx(sv[2].server));
    info(18, "S2 makes a snapshot");                rc_exec_snapshot(2);
}

// Trigger condition: Snapshot + No leadership change + No node failure + No network failure
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 18,19,20 and see what happens
void TestCluster_follower_log_no_more_than_leader_after_ae_success(CuTest *tc) {
    common_trace_snapshot_2_entries(tc);

    // Now S2's log base is 2, log count is 0. Leader request times out and broadcasts heartbeats (sends two entries to S2 again)
    info(19, "S0 request times out");               rc_request_timeout(0);
    info(19, "S0 sends AE 18 19 to S1 and S2");     assert_msg_seq_type(18, MSG_APPENDENTRIES); assert_msg_seq_type(19, MSG_APPENDENTRIES);
    
    // Invariant is violated.
    info(20, "S2 receives AE 19. Guess S2's log length?");
    assert_inv4(19);
}

// Trigger condition: Snapshot + No leadership change + No node failure + No network failure
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 22 and see what happens
void TestCluster_next_idx_greater_than_match_idx(CuTest *tc) {
    common_trace_snapshot_2_entries(tc);

    // Now S2's log base is 2, log count is 0.
    info(19, "S0 receives AER 14");                 rc_deliver(14, MSG_APPENDENTRIES_RESPONSE);
    info(19, "S0 aggressively sends AE 18");        assert_msg_seq_type(18, MSG_APPENDENTRIES);
    info(20, "S2 receives AE 18");                  rc_deliver(18, MSG_APPENDENTRIES);
    info(20, "S2 sends AER 19 to S0");              assert_msg_seq_type(19, MSG_APPENDENTRIES_RESPONSE);
    info(21, "S0 receives AER (true) 17");          rc_deliver(17, MSG_APPENDENTRIES_RESPONSE);
    info(21, "S0 advance next idx to 3");           CuAssertIntEquals(tc, 3, raft_node_get_next_idx(raft_get_node(sv[0].server, 2)));
    info(21, "S0 advance match idx to 2");          CuAssertIntEquals(tc, 2, raft_node_get_match_idx(raft_get_node(sv[0].server, 2)));

    // AER 19 should be a stale msg. However, Leader thinks it is log mismatch and sends a retry
    info(22, "S0 receives AER 19");                 rc_deliver(19, MSG_APPENDENTRIES_RESPONSE);
    info(22, "Guess next idx and match idx?");
    assert_inv11();
}

// Trigger condition: Snapshot + No leadership change + No node failure + No network failure
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 22 and see what happens
void TestCluster_ae_should_contain_entries_if_not_synchronized(CuTest *tc) {
    common_trace_snapshot_2_entries(tc);

    info(19, "S0 makes a snapshot");                rc_exec_snapshot(0);
    info(19, "S0 snapshot last included idx is 2"); CuAssertIntEquals(tc, 2, raft_get_snapshot_last_idx(sv[0].server));
    info(19, "S0 sends SS 18 to S2");               assert_msg_seq_type(18, MSG_SNAPSHOT);

    // S0 has one uncommitted entries
    info(20, "Client sends CMD1 to S0");            rc_client_operation(0, CMD1);
    info(20, "S0 sends AE 19 to S1");               assert_msg_seq_type(19, MSG_APPENDENTRIES);
    // S0 will not aggressively send ae because next idx 2 is snapshotted
    info(21, "S0 receives AER 14");                 rc_deliver(14, MSG_APPENDENTRIES_RESPONSE);
    info(21, "S0 advances next idx to 2");          CuAssertIntEquals(tc, 2, raft_node_get_next_idx(raft_get_node(sv[0].server, 2)));

    info(22, "S0 request times out. Guess how many entries sent to S2?");
    assert_inv12(0);
}

// Trigger condition: Snapshot + Leadership change + No node failure + Network unordered message
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 33 and see what happens
void TestCluster_current_term_is_monotonic(CuTest *tc) {
    common_trace_snapshot_2_entries(tc);

    // S0 gets more committed logs
    info(19, "Client sends CMD1 x2 to S0");         rc_client_operation(0, CMD1); rc_client_operation(0, CMD1);
    info(19, "S0 sends AE 18 to S1");               assert_msg_seq_type(18, MSG_APPENDENTRIES);
    info(20, "S1 receives AE 18");                  rc_deliver(18, MSG_APPENDENTRIES);
    info(20, "S1 sends AER 19 to S0");              assert_msg_seq_type(19, MSG_APPENDENTRIES_RESPONSE);
    info(21, "S0 receives AER 19");                 rc_deliver(19, MSG_APPENDENTRIES_RESPONSE);
    info(21, "S0 aggressively sends AE 20 to S1");  assert_msg_seq_type(20, MSG_APPENDENTRIES);
    info(22, "S1 receives AE 20");                  rc_deliver(20, MSG_APPENDENTRIES);
    info(22, "S1 sends AER 21 to S0");              assert_msg_seq_type(21, MSG_APPENDENTRIES_RESPONSE);
    info(23, "S0 receives AER 21");                 rc_deliver(21, MSG_APPENDENTRIES_RESPONSE);
    info(23, "S0 advances commit idx to 4");        CuAssertIntEquals(tc, 4, raft_get_commit_idx(sv[0].server));
    info(24, "S0 request times out");               rc_request_timeout(0);
    info(24, "S0 sends AE 22 23 to S1 and S2");     assert_msg_seq_type(22, MSG_APPENDENTRIES); assert_msg_seq_type(23, MSG_APPENDENTRIES);
    info(25, "S1 receives AE 22");                  rc_deliver(22, MSG_APPENDENTRIES);
    info(25, "S1 sends AER 24 to S0");              assert_msg_seq_type(24, MSG_APPENDENTRIES_RESPONSE);
    info(25, "S1 commit idx is 4");                 CuAssertIntEquals(tc, 4, raft_get_commit_idx(sv[1].server));

    // S1 becomes Leader
    info(26, "S1 becomes Candidate");               rc_election_timeout(1);
    info(26, "S1 sends RV 25 26 to S0 and S2");     assert_msg_seq_type(25, MSG_REQUESTVOTE); assert_msg_seq_type(26, MSG_REQUESTVOTE);
    info(27, "S2 receives RV 26");                  rc_deliver(26, MSG_REQUESTVOTE);
    info(27, "S2 sends RVR 27 (granted) to S2");    assert_msg_seq_type(27, MSG_REQUESTVOTE_RESPONSE);
    info(28, "S1 receives RVR 27");                 rc_deliver(27, MSG_REQUESTVOTE_RESPONSE);
    info(28, "S1 becomes Leader");                  CuAssertTrue(tc, raft_is_leader(sv[1].server));
    // S1 sends snapshot to S2
    info(29, "S1 sends AE 28 29 to S0 and S2");     assert_msg_seq_type(28, MSG_APPENDENTRIES); assert_msg_seq_type(29, MSG_APPENDENTRIES);
    info(30, "S2 receives AE 29");                  rc_deliver(29, MSG_APPENDENTRIES);
    info(30, "S2 sends AER 30 to S1");              assert_msg_seq_type(30, MSG_APPENDENTRIES_RESPONSE);
    info(31, "S1 receives AER 30");                 rc_deliver(30, MSG_APPENDENTRIES_RESPONSE);
    info(31, "S1 aggressively sends AE 31");        assert_msg_seq_type(31, MSG_APPENDENTRIES);
    info(32, "S1 makes a snapshot");                rc_exec_snapshot(1);
    info(32, "S1 snapshot last included idx is 4"); CuAssertIntEquals(tc, 4, raft_get_snapshot_last_idx(sv[1].server));
    info(32, "S1 sends SS 32 to S2");               assert_msg_seq_type(32, MSG_SNAPSHOT);

    info(33, "S2 receives SS 32. Guess S2 current term?");
    assert_inv5_before_action();
    rc_deliver(32, MSG_SNAPSHOT);
    assert_inv5_after_action();
}

// Trigger condition: Snapshot + Leadership change + Node restart + No Network failure
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 25/34 and see what happens
void TestCluster_will_exist_leader(CuTest *tc) {
    common_trace_snapshot_2_entries(tc);

    info(19, "S0 makes a snapshot");                rc_exec_snapshot(0);
    info(19, "S0 sends SS 18 to S2");               assert_msg_seq_type(18, MSG_SNAPSHOT);
    info(20, "S1 receives AE 15");                  rc_deliver(15, MSG_APPENDENTRIES);
    info(20, "S1 sends AER 19 to S0");              assert_msg_seq_type(19, MSG_APPENDENTRIES_RESPONSE);
    info(20, "S1 makes a snapshot");                rc_exec_snapshot(1);

    // Fault injection: S0 restart
    info(21, "S0 restarts and becomes Follower");   rc_restart(0);

    // S0 becomes Candidate
    info(22, "S0 becomes Candidate");               rc_election_timeout(0);
    info(22, "S0 sends RV 20 21 to S1 and S2");     assert_msg_seq_type(20, MSG_REQUESTVOTE); assert_msg_seq_type(21, MSG_REQUESTVOTE);
    info(23, "S1 receives RV 20");                  rc_deliver(20, MSG_REQUESTVOTE);
    info(23, "S1 sends RVR 22 to S0");              assert_msg_seq_type(22, MSG_REQUESTVOTE_RESPONSE);
    info(24, "S2 receives RV 21");                  rc_deliver(21, MSG_REQUESTVOTE);
    info(24, "S2 sends RVR 23 to S0");              assert_msg_seq_type(23, MSG_REQUESTVOTE_RESPONSE);
    info(25, "S0 receives RVR 22");                 rc_deliver(22, MSG_REQUESTVOTE_RESPONSE);
    info(25, "S0 receives RVR 23");                 rc_deliver(23, MSG_REQUESTVOTE_RESPONSE);
    if (raft_is_leader(sv[0].server)) {
        info(25, "S0 is Leader");
        return;
    } else {
        info(25, "S0 is not Leader");
    }

    // S1 becomes Candidate
    info(26, "S1 becomes Candidate");               rc_election_timeout(1);
    info(26, "S1 sends RV 24 25 to S0 and S2");     assert_msg_seq_type(24, MSG_REQUESTVOTE); assert_msg_seq_type(25, MSG_REQUESTVOTE);
    info(27, "S0 receives RV 24");                  rc_deliver(24, MSG_REQUESTVOTE);
    info(27, "S0 sends RVR 26 to S1");              assert_msg_seq_type(26, MSG_REQUESTVOTE_RESPONSE);
    info(28, "S2 receives RV 25");                  rc_deliver(25, MSG_REQUESTVOTE);
    info(28, "S2 sends RVR 27 to S1");              assert_msg_seq_type(27, MSG_REQUESTVOTE_RESPONSE);
    info(29, "S1 receives RVR 26");                 rc_deliver(26, MSG_REQUESTVOTE_RESPONSE);
    info(29, "S1 receives RVR 27");                 rc_deliver(27, MSG_REQUESTVOTE_RESPONSE);
    if (raft_is_leader(sv[1].server)) {
        info(29, "S1 is Leader");
        return;
    } else {
        info(29, "S1 is not Leader");
    }

    // S2 becomes Candidate
    info(30, "S2 becomes Candidate");               rc_election_timeout(2);
    info(30, "S2 sends RV 28 29 to S0 and S1");     assert_msg_seq_type(28, MSG_REQUESTVOTE); assert_msg_seq_type(29, MSG_REQUESTVOTE);
    info(31, "S0 receives RV 28");                  rc_deliver(28, MSG_REQUESTVOTE);
    info(31, "S0 sends RVR 30 to S2");              assert_msg_seq_type(30, MSG_REQUESTVOTE_RESPONSE);
    info(32, "S1 receives RV 29");                  rc_deliver(29, MSG_REQUESTVOTE);
    info(32, "S1 sends RVR 31 to S2");              assert_msg_seq_type(31, MSG_REQUESTVOTE_RESPONSE);
    info(33, "S2 receives RVR 30");                 rc_deliver(30, MSG_REQUESTVOTE_RESPONSE);
    info(33, "S2 receives RVR 31");                 rc_deliver(31, MSG_REQUESTVOTE_RESPONSE);
    if (raft_is_leader(sv[0].server)) {
        info(33, "S2 is Leader");
        return;
    } else {
        info(33, "S2 is not Leader");
    }

    info(34, "Guess how many Leaders?");
    assert_inv13();            
}

// Trigger condition: Snapshot + No leadership change + No node restart + Network unordered message
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 22 and see what happens
void TestCluster_ae_retry_once(CuTest *tc) {
    common_trace_snapshot_2_entries(tc);

    info(20, "S0 receives AER 14");                 rc_deliver(14, MSG_APPENDENTRIES_RESPONSE);
    info(20, "S0 aggressively sends AE 18 to S2");  assert_msg_seq_type(18, MSG_APPENDENTRIES);
    info(21, "S2 receives AE 18");                  rc_deliver(18, MSG_APPENDENTRIES);
    info(21, "S2 sends AER 19 to S0");              assert_msg_seq_type(19, MSG_APPENDENTRIES_RESPONSE);
    info(22, "S0 receives AER 19");                 rc_deliver(19, MSG_APPENDENTRIES_RESPONSE);
    #ifdef TEST_CLUSTER_PRINT_LOG
    printf(" ? S0 should not aggressively send AE, current seq: %ld\n", get_seq());
    #endif
    CuAssertTrue(tc, get_seq() == 19);
}

// Trigger condition: Snapshot + No leadership change + No node restart + Network unordered message + Network partition
// Run this testcase with CFLAGS="-DTEST_CLUSTER_PRINT_LOG", check STATE 24 and see what happens
void TestCluster_handle_snapshot_make_progress(CuTest *tc) {
    // init 3 servers, S0 becomes Leader
    info(1, "init 3 servers");                      rc_init_cluster(3, tc);
    info(2, "S0 becomes Candidate");                rc_election_timeout(0);
    info(2, "S0 sends RV 1 2 to S1 and S2");        assert_msg_seq_type(1, MSG_REQUESTVOTE); assert_msg_seq_type(2, MSG_REQUESTVOTE);
    info(3, "S1 receives RV 1");                    rc_deliver(1, MSG_REQUESTVOTE);
    info(3, "S1 sends RVR 3 (granted) to S0");      assert_msg_seq_type(3, MSG_REQUESTVOTE_RESPONSE);
    info(4, "S0 receives RVR 3 and become Leader"); rc_deliver(3, MSG_REQUESTVOTE_RESPONSE);
    info(4, "S0 sends AE 4 5 to S1 and S2");        assert_msg_seq_type(4, MSG_APPENDENTRIES); assert_msg_seq_type(5, MSG_APPENDENTRIES);
    info(5, "S1 S2 receives AE 4 5");               rc_deliver(4, MSG_APPENDENTRIES); rc_deliver(5, MSG_APPENDENTRIES);
    info(5, "S1 S2 sends AER 6 7");                 assert_msg_seq_type(6, MSG_APPENDENTRIES_RESPONSE); assert_msg_seq_type(7, MSG_APPENDENTRIES_RESPONSE);
    info(6, "S0 receives AER 6 7");                 rc_deliver(6, MSG_APPENDENTRIES_RESPONSE); rc_deliver(7, MSG_APPENDENTRIES_RESPONSE);
    // Fault injection: network partition
    info(7, "Network partition add S0");            add_to_network_partition(0);
    info(8, "Client sends CMD1 x3 to S0");          rc_client_operation(0, CMD1); rc_client_operation(0, CMD1); rc_client_operation(0, CMD1);
    // S1 becomes Leader
    info(9, "S1 becomes Candidate");                rc_election_timeout(1);
    info(9, "S1 sends RV 8 to S2");                 assert_msg_seq_type(8, MSG_REQUESTVOTE);
    info(10, "S2 receives RV 8");                   rc_deliver(8, MSG_REQUESTVOTE);
    info(10, "S2 sends RVR 9 (granted) to S1");     assert_msg_seq_type(9, MSG_REQUESTVOTE_RESPONSE);
    info(11, "S1 receives RVR 9 and become Leader");rc_deliver(9, MSG_REQUESTVOTE_RESPONSE);
    info(11, "S1 sends AE 10 to S2");               assert_msg_seq_type(10, MSG_APPENDENTRIES);
    info(12, "S2 receives AE 10");                  rc_deliver(10, MSG_APPENDENTRIES);
    info(12, "S2 sends AER 11");                    assert_msg_seq_type(11, MSG_APPENDENTRIES_RESPONSE);
    info(13, "S0 receives AER 11");                 rc_deliver(11, MSG_APPENDENTRIES_RESPONSE);
    // S1 commits 2 entries and makes a snapshot
    info(14, "Client sends CMD1 x2 to S1");         rc_client_operation(1, CMD1); rc_client_operation(1, CMD1);
    info(14, "S1 sends AE 12 to S2");               assert_msg_seq_type(12, MSG_APPENDENTRIES);
    info(15, "S2 receives AE 12");                  rc_deliver(12, MSG_APPENDENTRIES);
    info(15, "S2 sends AER 13 to S1");              assert_msg_seq_type(13, MSG_APPENDENTRIES_RESPONSE);
    info(16, "S1 receives AER 13");                 rc_deliver(13, MSG_APPENDENTRIES_RESPONSE);
    info(16, "S1 aggressively sends AE 14 to S2");  assert_msg_seq_type(14, MSG_APPENDENTRIES);
    info(17, "S2 receives AE 14");                  rc_deliver(14, MSG_APPENDENTRIES);
    info(17, "S2 sends AER 15");                    assert_msg_seq_type(15, MSG_APPENDENTRIES_RESPONSE);
    info(18, "S1 receives AER 15");                 rc_deliver(15, MSG_APPENDENTRIES_RESPONSE);
    info(18, "S1 commit idx is 2");                 CuAssertIntEquals(tc, 2, raft_get_commit_idx(sv[1].server));
    info(19, "S1 makes a snapshot");                rc_exec_snapshot(1);
    info(19, "S1 snapshot last included idx is 2"); CuAssertIntEquals(tc, 2, raft_get_snapshot_last_idx(sv[1].server));
    // Network recover
    info(20, "Network recover");                    clear_network_partition();
    info(21, "S1 request times out");               rc_request_timeout(1);
    info(21, "S1 sends SS 16 to S0");               assert_msg_seq_type(16, MSG_SNAPSHOT);
    int seq;
    if (msg_hook.type == MSG_APPENDENTRIES) {
        // bug fixed: S1 sends SS won't cancel subsequent sendings
        info(21, "S1 sends AE 17 to S2");           assert_msg_seq_type(17, MSG_APPENDENTRIES);
        info(22, "S0 receives SS 16");              rc_deliver(16, MSG_SNAPSHOT);
        info(22, "S0 sends AER 18 to S1");          assert_msg_seq_type(18, MSG_APPENDENTRIES_RESPONSE);
        info(23, "S1 receives AER 18");             rc_deliver(18, MSG_APPENDENTRIES_RESPONSE);
        info(24, "S1 request times out");           rc_request_timeout(1);
        seq = 19;
    }
    else {
        info(22, "S0 receives SS 16");              rc_deliver(16, MSG_SNAPSHOT);
        info(22, "S0 sends AER 17 to S1");          assert_msg_seq_type(17, MSG_APPENDENTRIES_RESPONSE);
        info(23, "S1 receives AER 17");             rc_deliver(17, MSG_APPENDENTRIES_RESPONSE);
        info(24, "S1 request times out");           rc_request_timeout(1);
        seq = 18;
    }
    info(24, "Guess what type of msg S1 sent to S0?");
    #ifdef TEST_CLUSTER_PRINT_LOG
    printf(" ? S1 should send AE, really sent: %s\n", get_msg_type_str(get_msg(seq)->type));
    #endif
    CuAssertTrue(tc, get_msg(seq)->type == MSG_APPENDENTRIES);
}

